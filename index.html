<!doctype html>

<html>
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans">
		<link rel="stylesheet" href="leaflet/leaflet.css" />
		<script src="leaflet/leaflet.js"></script>
		<link rel="stylesheet" href="leaflet/leaflet.fullscreen.css" />
		<script src="leaflet/leaflet.fullscreen.js"></script>		
		<script src="leaflet/leaflet-svg-shape-markers.min.js"></script>	
		<script src="https://unpkg.com/simple-statistics@7.8.0/dist/simple-statistics.min.js"></script>	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.0/chroma.min.js"></script>
		
		<style>
			html, body {
				height: 100%;
				margin: 0;
				font-family: 'Open Sans', 'OpenSans-Local';
				font-style: normal;				
			}
			
			#map {
				position: absolute;
				margin:  auto;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
			}
			#infopanel {
				position: absolute;
				margin:  auto;
				bottom: 30px;
				right: 20px;
				width: 30%;
				z-index: 10001;
				background-color: #ffffff;
				border-radius: 3px;
				box-shadow: 3px 3px 8px #00000055;
				padding: 10px;
			}
			.popuprow {
				display: flex; 
				flex-direction: row; 
				justify-content: space-between;
			}
			.info {
				padding: 6px 8px;
				font: 14px/16px Arial, Helvetica, sans-serif;
				background: white;
				background: rgba(255,255,255,0.8);
				box-shadow: 0 0 15px rgba(0,0,0,0.2);
				border-radius: 5px;
			}
			.legend {
				line-height: 18px;
				color: #555;
			}
			.legend i {
				width: 18px;
				height: 18px;
				float: left;
				margin-right: 8px;
				opacity: 0.7;
			}
						
		</style>
	</head>
	<body>
		
				<div id="map"></div>
				
		<script>
		
			// map div object, main Leaflet object:
			var map = L.map('map').setView([0,0], 3); 
			map.addControl(new L.Control.Fullscreen());
			
			// base maps
			var OSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
			}).addTo(map);
				
			
			var values = [];
			var classes = [];
			var colors = [];
			var radiuses = [];
			var widths = [];
			var field;

			function getColor(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						return colors[i];
					} 					
				}
				return colors.at(-1);	// highest group
			}
			
			// EXPERIMENTAL LINE WEIGHT 
			function getWeight(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						console.log(widths[i])
						return widths[i];
					} 					
				}
				return widths.at(-1);	// highest group
			}

			function getRadius(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						return radiuses[i];
					} 					
				}
				return radiuses.at(-1);	// highest group
			}
			function stylePolygon(value){
				console.log('value to classify: ', value)
				return {
					fillColor: getColor(value),
					fillOpacity: 0.7,
					color: 'white',
					weight: 2
				};			
			}
			function stylePoint_color(value){
				return {
					fillColor: getColor(value),
					fillOpacity: 1,
					color: "black",
					weight: 1.5,
					shape: "circle",
					radius: 8
				};			
			}
			function stylePoint_size(value){
				return {
					fillColor: "orange",
					fillOpacity: 1,
					color: "black",
					weight: 1,
					shape: "circle",
					radius: getRadius(value)
				};			
			}
			function styleLine_color(value){
				console.log(value)
				return {
					color: getColor(value),
					weight: 3
				};			
			}
			function styleLine_width(value){
				console.log(value)
				return {
					/*color: "orange",*/
					weight: getWeight(value)
				};			
			}
			
			// get n[classes] of point radiuses, line widths
			function pointMode_size_radiuses([min, max]){
				radiuses = [];
				
				var step = (max-min)/classes.length;
				for (var i = 1; i<classes.length; i++) {
					var curr = min+step*i;
					radiuses.push(curr);
				}
				radiuses.push(max);
				console.log('points: radius categories:', radiuses)
			}
			function lineMode_width([min, max]){
				widths = [];
				
				var step = (max-min)/classes.length;
				for (var i = 1; i<classes.length; i++) {
					var curr = min+step*i;
					widths.push(curr);
				}
				widths.push(max);
				console.log('lines: width/weight categories:', widths)
			}

			function start(options){
				console.group('Classification and legend generation');
				console.log('Mode:', options.mode);
				console.log('Point mode:', options.pointMode);
				console.log('Point size:', options.pointSizeMin, '-', options.pointSizeMax);
				console.log('Line mode:', options.lineMode);
				console.log('Line width:', options.lineWidthMin, '-', options.lineWidthMax);
				console.log('Number of classes:', options.classes);
				console.log('Color palette:', options.colorRamp);
				console.log('Legend ascending:', options.legendAscending);
				console.log('Legend rounding:', options.legendRounding);
				console.log('Color ramp reverse:', options.reverseColorRamp);
				console.log('Title:', options.legendTitle);
				console.log('Field:', options.field);
				console.log(options);
				console.groupEnd();
				
				// OPTIONS extract
				var mode = options.mode;
				var mode_point = options.pointMode;
				var pointSize = [options.pointSizeMin, options.pointSizeMax];
				var lineWidth = [options.lineWidthMin, options.lineWidthMax];
				var mode_line = options.lineMode;
				var classnum = options.classes;
				var colorramp = options.colorRamp;
				var asc = options.legendAscending;
				var colorramp_rev = options.reverseColorRamp;
				var legendtitle = options.legendTitle;
				var legendrounding = options.legendRounding;
				var field = options.field;

				var features_info = { Point: 0, MultiPoint: 0, LineString: 0, MultiLineString: 0, Polygon: 0, MultiPolygon: 0};

				// feature attribute value extraction to array
				testdata.eachLayer(function(layer) {
					if (layer.feature.properties[field] != null) {
						values.push(layer.feature.properties[field]);
					} else {
						console.error('Attribute field does not exist in GeoJSON.')
						return;
					};
				});
				
				console.log('Loaded values from GeoJSON (field: '+field+'):', values);	
				
				// classification process
				var success = false;
				if (classnum > 2 && classnum < values.length) {				
					switch (mode) {
						case 'jenks':	
							classes = ss.jenks(values, classnum);
							classes.pop(); // remove last, since its the max value
							console.log('Jenks classes: ', classes);
							success = true;
							break;
						case 'equalinterval':
							classes = [];
							var minmax = ss.extent(values);
							console.log('min:', minmax[0], ', max:', minmax[1])
							var range = minmax[1]-minmax[0];
							console.log('data range:', range)
							var oneclass = range/classnum;
							console.log('one class:', oneclass);
							for (var i=minmax[0]; i<range;) {
								classes.push(i);
								i = i + oneclass;
							}
							console.log('EI classes: ', classes);
							success = true;
							break;
						case 'quantile':
							classes = [];
							for (var i = 0; i<classnum; i++) {
								var currentq = (1/classnum)*i;
								classes.push(ss.quantile(values, currentq));
							}				
							console.warn('Quantile classes at the middle might be wrong (compared to GIS SW)');		
							console.log('Quantile classes: ', classes);	
							success = true;
							break;
						// EXPERIMENTAL LOG
						case 'logarithmic':
							classes = [];
							var minmax = ss.extent(values);
							console.log('min:', minmax[0], ', max:', minmax[1])							
							for (var i = 0; i<classnum; i++) {
								var x = Math.pow(10, i);
								classes.push(x);
							}					
							console.log('Logarithmic classes: ', classes);	
							success = true;
							break;
						default:
							console.error('wrong classification type (choose from "jenks", "equalinterval", "quantile")')
					}
					if (success) {
						colors = chroma.scale(colorramp).colors(classnum);
						if (colorramp_rev) {
							console.log('reversing colorramp')
							colors.reverse(); 
						};
					}
					if (mode_point == "size") {
						pointMode_size_radiuses(pointSize);
					}
					if (mode_line == "width") {
						lineMode_width(lineWidth);
					}
					generateLegend(legendtitle, asc, legendrounding, mode_line, mode_point);
				} else {
					console.error('Classnumber out of range (must be: 2 < x <', values.length, '(featurecount))!');
					return;
				}
				
				// setting symbology to features
				testdata.eachLayer(function(layer) {
					console.log('feature type:', layer.feature.geometry.type)

					// gather info of geojson feature types
					switch (layer.feature.geometry.type) {
						case 'Point': 	
							features_info.Point += 1;
							break;
						case 'MultiPoint': 	
							features_info.MultiPoint += 1;
							break;
						case 'LineString': 	
							features_info.LineString += 1;
							break;
						case 'MultiLineString': 	
							features_info.MultiLineString += 1;
							break;
						case 'Polygon': 	
							features_info.Polygon += 1;
							break;
						case 'MultiPolygon': 	
							features_info.MultiPolygon += 1;
							break;
						default:
							features_info.Unknown += 1;
					}

					if (layer.feature.geometry.type == "Point") {
						var coords = layer.feature.geometry.coordinates;
						var marker = L.shapeMarker([coords[0], coords[1]] = [coords[1], coords[0]], (options.pointMode == "color" ? stylePoint_color(layer.feature.properties[field]) : stylePoint_size(layer.feature.properties[field])));
						marker.addTo(map);
						testdata.remove(); // to hide default icon markers - not the most elegant way of course
					}
					if (layer.feature.geometry.type == "LineString" || layer.feature.geometry.type == "MultiLineString") {
						layer.setStyle((options.lineMode == "width" ? styleLine_width(layer.feature.properties[field]) : styleLine_color(layer.feature.properties[field])))
					}
					if (layer.feature.geometry.type == "Polygon" || layer.feature.geometry.type == "MultiPolygon") {
						layer.setStyle(stylePolygon(layer.feature.properties[field]))
					}
					
				});

				console.log('Feature types in GeoJSON:', features_info)
			}
				
			var x=new XMLHttpRequest();
			x.open('get', 'points.geojson', false);
			//x.open('get', 'us-states.geojson', false);
			//x.open('get', 'rivers.geojson', false);
			//x.open('get', 'test.geojson', false);
			x.send();
			var d=JSON.parse(x.responseText);
			var testdata = L.geoJSON(d).addTo(map); 		// FOR POINTS, YOU MIGHT NEED TO DISABLE ADDTOMAP to avoid default markers (Custom markers are drawn separately)
			map.fitBounds(testdata.getBounds());
			
			//start('quantile', 5, 'RdPu', 'Terfogat', 'Area (m<sup>2</sup>)'); 		// mode, numclasses, colorramp, field, legendtitle OLD
			start({
				mode: 'quantile',							// classification method (jenks, quantile, equalinterval)
				classes: 3,									// desired number of classes
				pointMode: 'size', 						// POINT FEATURES: fill "color" or "size" (size EXPERIMENTAL!!)
				pointSizeMin: 2,							// POINT FEATURES: when pointMode: "size", define min point circle radius
				pointSizeMax: 10,							// POINT FEATURES: when pointMode: "size", define max point circle radius
				lineMode: 'color', 							// LINE FEATURES: stroke "color" or "width" (width EXPERIMENTAL!!)
				lineWidthMin: 1,							// LINE FEATURES: when lineMode: "width", define min stroke width
				lineWidthMax: 10,							// LINE FEATURES: when lineMode: "width", define max stroke width (max 25)
				colorRamp: 'PuRd',							// color ramp to use in symbology
				legendAscending: false,						// true = values in legend will be ascending (low first, high last)
				reverseColorRamp: false,					// true = reverse the chosen color ramp, both in symbology on map and legend colors. 
															// Useful if you found a great looking colorramp (green to red), but would prefer reversed colors 
															// (for example to match visual implications about colors: green implies positive, red implies negative phenomena)
				field: 'Terfogat', 						// target attribute field name. Case-sensitive!
				legendTitle: 'Length (m)',					// title for legend (usually a description of visualized data)
				legendRounding: true						// false = disable class boundary value rounding
			}); 
			
			// color ramps:
			//    for sequential data: 	OrRd, PuBu, BuPu, Oranges, BuGn, YlOrBr, YlGn, Reds, RdPu, Greens, YlGnBu, 
			//							Purples, GnBu, Greys, YlOrRd, PuRd, Blues, PuBuGn
			//    for diverging data:	Spectral, RdYlGn, RdBu, PiYG, PRGn, RdYlBu, BrBG, RdGy, PuOr
 			//    for qualitative data:	Accent, Set1, Paired, Set2, Dark2, Set3, Pastel1, Pastel2
			
			
			
			function generateLegend(title, asc, round, mode_line, mode_point) {				
				var legend = L.control({position: 'bottomleft'});
				
				if (round) {
					for (var i=0; i<classes.length; i++) {
						classes[i] = classes[i].toFixed(0);
					}
					console.log('Class break values have been rounded to whole numbers.')
				}
				
				legend.onAdd = function (map) {
					var div = L.DomUtil.create('div', 'info legend');
					// legend title:
					div.innerHTML += '<div style="font-weight: bold; display: flex; justify-content: center; margin-bottom: 5px; max-width: 170px;">' + title + '</div>';
					// legenditems container
					var container = '';
					if (asc) {
						// ascending legend
						if (mode_line == "width") {
							// line width
							for (var i = 0; i < classes.length; i++) {
								console.log('Legend: building line', i+1)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
											'<line x1="0" y1="12.5" x2="25" y2="12.5" style="stroke-width: '+widths[i]+'; stroke: #3687fa;"/>'+
										'</svg>'+
										'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] + '<br>' : ' <')+'</div>'+
									'</div>';
							}
						} else if (mode_point == "size") {
							// point size
							for (var i = 0; i < classes.length; i++) {
								console.log('Legend: building line', i+1)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
											'<circle cx="12.5" cy="12.5" r="'+radiuses[i]+'" style="stroke: black; fill: orange;"/>'+
										'</svg>'+
										'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] + '<br>' : ' <')+'</div>'+
									'</div>';
							}
						} else {
							for (var i = 0; i < classes.length; i++) {
								console.log('Legend: building line', i+1)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<i style="background: ' + colors[i] + '"></i> ' +
										'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] + '<br>' : ' <')+'</div>'+
									'</div>';
							}
						}
					} else {
						// descending legend
						if (mode_line == "width") {
							// line width
							for (var i = classes.length; i > 0; i--) {
								console.log('Legend: building line', i)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
											'<line x1="0" y1="12.5" x2="25" y2="12.5" style="stroke-width: '+widths[i-1]+'; stroke: #3687fa;"/>'+
										'</svg>'+
									'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <<br>' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1] + '<br>'))+'</div>'+
									'</div>'
							}
						} else if (mode_point == "size") {
							// point size
							for (var i = classes.length; i > 0; i--) {
								console.log('Legend: building line', i)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
											'<circle cx="12.5" cy="12.5" r="'+radiuses[i-1]+'" style="stroke: black; fill: orange;"/>'+
										'</svg>'+
										'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <<br>' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1] + '<br>'))+'</div>'+
									'</div>';
							}
						} else {
							for (var i = classes.length; i > 0; i--) {
								console.log('Legend: building line', i)
								container +=
									'<div style="display: flex; flex-direction: row; align-items: center">'+
										'<i style="background: ' + colors[i-1] + '"></i>' +
										'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <<br>' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1] + '<br>'))+'</div>'+
									'</div>'
							}
						}
						
					};
					div.innerHTML += container;
					return div;
				};
				
				
				console.log('Legend generated.');
				legend.addTo(map);
			}
			
			
			
			function unixTimestampSolver(ts, mode) {
				if (mode == "hhmmss") {
					var date = new Date(ts*1000).toLocaleString("hu-HU", {hour: '2-digit', minute: '2-digit', second: '2-digit'});				
				} else if (mode == "full") {
					var date = new Date(ts*1000).toLocaleString("hu-HU");				
				} else if (mode == "fullutc") {
					var date = new Date(ts*1000).toUTCString();				
				}
				return date;
			}
				
				
				
				
				
			
			ss.jenks = function(data, n_classes) {

				// sort data in numerical order
				data = data.slice().sort(function (a, b) { return a - b; });

				// get our basic matrices
				var matrices = ss.jenksMatrices(data, n_classes),
					// we only need lower class limits here
					lower_class_limits = matrices.lower_class_limits,
					k = data.length - 1,
					kclass = [],
					countNum = n_classes;

				// the calculation of classes will never include the upper and
				// lower bounds, so we need to explicitly set them
				kclass[n_classes] = data[data.length - 1];
				kclass[0] = data[0];

				// the lower_class_limits matrix is used as indexes into itself
				// here: the `k` variable is reused in each iteration.
				while (countNum > 1) {
					kclass[countNum - 1] = data[lower_class_limits[k][countNum] - 2];
					k = lower_class_limits[k][countNum] - 1;
					countNum--;
				}

				return kclass;
			};
			
				ss.jenksMatrices = function(data, n_classes) {

					// in the original implementation, these matrices are referred to
					// as `LC` and `OP`
					//
					// * lower_class_limits (LC): optimal lower class limits
					// * variance_combinations (OP): optimal variance combinations for all classes
					var lower_class_limits = [],
						variance_combinations = [],
						// loop counters
						i, j,
						// the variance, as computed at each step in the calculation
						variance = 0;

					// Initialize and fill each matrix with zeroes
					for (i = 0; i < data.length + 1; i++) {
						var tmp1 = [], tmp2 = [];
						for (j = 0; j < n_classes + 1; j++) {
							tmp1.push(0);
							tmp2.push(0);
						}
						lower_class_limits.push(tmp1);
						variance_combinations.push(tmp2);
					}

					for (i = 1; i < n_classes + 1; i++) {
						lower_class_limits[1][i] = 1;
						variance_combinations[1][i] = 0;
						// in the original implementation, 9999999 is used but
						// since Javascript has `Infinity`, we use that.
						for (j = 2; j < data.length + 1; j++) {
							variance_combinations[j][i] = Infinity;
						}
					}

					for (var l = 2; l < data.length + 1; l++) {

						// `SZ` originally. this is the sum of the values seen thus
						// far when calculating variance.
						var sum = 0, 
							// `ZSQ` originally. the sum of squares of values seen
							// thus far
							sum_squares = 0,
							// `WT` originally. This is the number of 
							w = 0,
							// `IV` originally
							i4 = 0;

						// in several instances, you could say `Math.pow(x, 2)`
						// instead of `x * x`, but this is slower in some browsers
						// introduces an unnecessary concept.
						for (var m = 1; m < l + 1; m++) {

							// `III` originally
							var lower_class_limit = l - m + 1,
								val = data[lower_class_limit - 1];

							// here we're estimating variance for each potential classing
							// of the data, for each potential number of classes. `w`
							// is the number of data points considered so far.
							w++;

							// increase the current sum and sum-of-squares
							sum += val;
							sum_squares += val * val;

							// the variance at this point in the sequence is the difference
							// between the sum of squares and the total x 2, over the number
							// of samples.
							variance = sum_squares - (sum * sum) / w;

							i4 = lower_class_limit - 1;

							if (i4 !== 0) {
								for (j = 2; j < n_classes + 1; j++) {
									if (variance_combinations[l][j] >=
										(variance + variance_combinations[i4][j - 1])) {
										lower_class_limits[l][j] = lower_class_limit;
										variance_combinations[l][j] = variance +
											variance_combinations[i4][j - 1];
									}
								}
							}
						}

						lower_class_limits[l][1] = 1;
						variance_combinations[l][1] = variance;
					}

					return {
						lower_class_limits: lower_class_limits,
						variance_combinations: variance_combinations
					};
				};
			
			  </script>	
	</body>
</html>