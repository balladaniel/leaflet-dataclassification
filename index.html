<!doctype html>

<html>
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans">
		<link rel="stylesheet" href="leaflet/leaflet.css" />
		<script src="leaflet/leaflet.js"></script>
		<link rel="stylesheet" href="leaflet/leaflet.fullscreen.css" />
		<script src="leaflet/leaflet.fullscreen.js"></script>		
		<script src="leaflet/leaflet-svg-shape-markers.min.js"></script>	
		<script src="https://unpkg.com/simple-statistics@7.8.0/dist/simple-statistics.min.js"></script>	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.0/chroma.min.js"></script>
		
		<style>
			html, body {
				height: 100%;
				margin: 0;
				font-family: 'Open Sans', 'OpenSans-Local';
				font-style: normal;				
			}
			
			#map {
				position: absolute;
				margin:  auto;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
			}
			#infopanel {
				position: absolute;
				margin:  auto;
				bottom: 30px;
				right: 20px;
				width: 30%;
				z-index: 10001;
				background-color: #ffffff;
				border-radius: 3px;
				box-shadow: 3px 3px 8px #00000055;
				padding: 10px;
			}
			.popuprow {
				display: flex; 
				flex-direction: row; 
				justify-content: space-between;
			}
			.info {
				padding: 6px 8px;
				font: 14px/16px Arial, Helvetica, sans-serif;
				background: white;
				background: rgba(255,255,255,0.8);
				box-shadow: 0 0 15px rgba(0,0,0,0.2);
				border-radius: 5px;
			}
			.legend {
				line-height: 18px;
				color: #555;
			}
			.legend i {
				width: 18px;
				height: 18px;
				float: left;
				margin-right: 8px;
				opacity: 0.7;
			}
						
		</style>
	</head>
	<body>
		
		<div id="map"></div>
				
		<script>
		
			// map div object, main Leaflet object:
			var map = L.map('map').setView([0,0], 3); 
			map.addControl(new L.Control.Fullscreen());
			
			// base maps
			var OSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
			}).addTo(map);
				
			
			var values = [];
			var classes = [];
			var colors = [];
			var radiuses = [];
			var widths = [];
			var field;

			// value evaluators to match classes
			function getColor(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						return colors[i];
					} 					
				}
				return colors.at(-1);	// highest group
			}
			function getWeight(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						return widths[i];
					} 					
				}
				return widths.at(-1);	// highest group
			}
			function getRadius(d) {
				for (var i = 0; i<classes.length; i++) {
					if (d < classes[i+1]) {
						return radiuses[i];
					} 					
				}
				return radiuses.at(-1);	// highest group
			}

			// stylers
			function stylePoint_color(value){
				return {
					fillColor: getColor(value),
					fillOpacity: 1,
					color: "black",
					weight: 1,
					shape: "circle",
					radius: 8
				};			
			}
			function stylePoint_size(value){
				return {
					fillColor: "orange",
					fillOpacity: 1,
					color: "black",
					weight: 1,
					shape: "circle",
					radius: getRadius(value)
				};			
			}
			function styleLine_color(value){
				return {
					color: getColor(value),
					weight: 3
				};			
			}
			function styleLine_width(value){
				return {
					/*color: "orange",*/
					weight: getWeight(value)
				};			
			}
			function stylePolygon(value){
				return {
					fillColor: getColor(value),
					fillOpacity: 0.7,
					color: 'white',
					weight: 2
				};			
			}
			
			// get n categories of point radiuses, line widths for symbology
			function pointMode_size_radiuses([min, max]){
				radiuses = [];
				
				var step = (max-min)/classes.length;
				for (var i = 1; i<classes.length; i++) {
					var curr = min+step*i;
					radiuses.push(curr);
				}
				radiuses.push(max);
				console.log('points: radius categories:', radiuses)
			}
			function lineMode_width([min, max]){
				widths = [];
				
				var step = (max-min)/classes.length;
				for (var i = 1; i<classes.length; i++) {
					var curr = min+step*i;
					widths.push(curr);
				}
				widths.push(max);
				console.log('lines: width categories:', widths)
			}

			function start(options){
				console.group('Classification and legend generation');
				console.log('Mode:', options.mode);
				console.log('Point mode:', options.pointMode);
				console.log('Point size:', options.pointSizeMin, '-', options.pointSizeMax);
				/*console.log('Point shape:', options.pointShape);*/
				console.log('Line mode:', options.lineMode);
				console.log('Line width:', options.lineWidthMin, '-', options.lineWidthMax);
				console.log('Number of classes:', options.classes);
				console.log('Color palette:', options.colorRamp);
				console.log('Color palette custom:', options.colorCustom);
				console.log('Legend ascending:', options.legendAscending);
				console.log('Legend rounding:', options.legendRounding);
				console.log('Color ramp reverse:', options.reverseColorRamp);
				console.log('Title:', options.legendTitle);
				console.log('Field:', options.field);
				console.log(options);
				console.groupEnd();

				// Stop if required options are missing
				if (options.mode == null || options.classes == null || options.field == null) {
					console.error('One or more required options are missing: "mode", "classes", "field".')
					return;
				}
				
				// OPTIONS extract and checks
				var mode = options.mode;
				var mode_point;
				(options.pointMode != null ? mode_point = options.pointMode : mode_point = 'color'); 		// default
				var pointSize = [options.pointSizeMin, options.pointSizeMax];
				(pointSize[0] == null ? pointSize[0] = 2 : ''); 		 									// default									
				(pointSize[1] == null ? pointSize[1] = 10 : '');											// default
				/*var pointShape;
				(options.pointShape != null ? pointShape = options.pointShape : pointShape = 'circle' )*/ 	// default
				var lineWidth = [options.lineWidthMin, options.lineWidthMax];
				(lineWidth[0] == null ? lineWidth[0] = 1 : ''); 		 									// default									
				(lineWidth[1] == null ? lineWidth[1] = 15 : '');											// default
				var mode_line;
				(options.lineMode != null ? mode_line = options.lineMode : mode_line = 'color'); 			// default
				var classnum = options.classes;
				if (classnum > 10) { console.warn("Don't be silly, both map and legend will look incomprehensible. Overriding classnumber with 10."); classnum = 10 }; // over 10
				var colorramp;
				(options.colorRamp != null ? colorramp = options.colorRamp : colorramp = 'PuRd'); 			// default
				var colorramp_custom = options.colorCustom;
				if (colorramp_custom != null ) {
					if (colorramp_custom.length == 1) {
						console.error('Custom colors: only one color was set. At least 2 are required. Falling back to colorRamp.');
					} else {
						// if an array of at least 2 colors are set, custom color ramp. Otherwise, fallback to colorramp.
						(colorramp_custom[0] == null || colorramp_custom[1] == null ? '' : colorramp = colorramp_custom);	
					}
				}
				var asc;
				(options.legendAscending != null ? asc = options.legendAscending : asc = false); 			// default
				var colorramp_rev;
				(options.reverseColorRamp != null ? colorramp_rev = options.reverseColorRamp : colorramp_rev = false); 		// default
				var field = options.field;
				var legendtitle;
				(options.legendTitle != null ? legendtitle = options.legendTitle : legendtitle = field); 	// default
				var legendrounding;
				(options.legendRounding != null ? legendrounding = options.legendRounding : legendrounding = true); 		// default

				var features_info = { Point: 0, MultiPoint: 0, LineString: 0, MultiLineString: 0, Polygon: 0, MultiPolygon: 0};
				var typeOfFeatures = 'unknown';

				testdata.eachLayer(function(layer) {
					// gather info of geojson feature types
					switch (layer.feature.geometry.type) {
						case 'Point': 	
							features_info.Point += 1;
							break;
						case 'MultiPoint': 	
							features_info.MultiPoint += 1;
							break;
						case 'LineString': 	
							features_info.LineString += 1;
							break;
						case 'MultiLineString': 	
							features_info.MultiLineString += 1;
							break;
						case 'Polygon': 	
							features_info.Polygon += 1;
							break;
						case 'MultiPolygon': 	
							features_info.MultiPolygon += 1;
							break;
						default:
							features_info.Unknown += 1;
					}

					// feature attribute value extraction to array
					if (layer.feature.properties[field] != null) {
						values.push(layer.feature.properties[field]);
					} else {
						console.error('Attribute field "'+field+'" does not exist in GeoJSON. Please note that attribute field input is case-sensitve.')
						return;
					};
				});

				console.log('Loaded values from GeoJSON (field: '+field+'):', values);	

				typeOfFeatures = Object.keys(features_info).reduce((a, b) => features_info[a] > features_info[b] ? a : b);
				console.log('Dominant feature type in GeoJSON:', typeOfFeatures)

				// classification process
				var success = false;
				if (classnum > 2 && classnum < values.length) {				
					switch (mode) {
						case 'jenks':	
							classes = ss.jenks(values, classnum);
							classes.pop(); // remove last, since its the max value
							console.log('Jenks classes: ', classes);
							success = true;
							break;
						case 'equalinterval':
							classes = [];
							var minmax = ss.extent(values);
							console.log('min:', minmax[0], ', max:', minmax[1])
							var range = minmax[1]-minmax[0];
							console.log('data range:', range)
							var oneclass = range/classnum;
							console.log('one class:', oneclass);
							for (var i=minmax[0]; i<range;) {
								classes.push(i);
								i = i + oneclass;
							}
							console.log('EI classes: ', classes);
							success = true;
							break;
						case 'quantile':
							classes = [];
							for (var i = 0; i<classnum; i++) {
								var currentq = (1/classnum)*i;
								classes.push(ss.quantile(values, currentq));
							}				
							console.warn('Quantile classes at the middle might be different, compared to GIS SW');		
							console.log('Quantile classes: ', classes);	
							success = true;
							break;
						// EXPERIMENTAL LOG
						case 'logarithmic':
							classes = [];
							var minmax = ss.extent(values);
							console.log('min:', minmax[0], ', max:', minmax[1])							
							for (var i = 0; i<classnum; i++) {
								var x = Math.pow(10, i);
								classes.push(x);
							}					
							console.log('Logarithmic classes: ', classes);	
							success = true;
							break;
						default:
							console.error('wrong classification type (choose from "jenks", "equalinterval", "quantile")')
					}
					if (success) {
						try {
							colors = chroma.scale(colorramp).colors(classnum);
						} catch (error) {
							console.error(error)
							console.error('Make sure chosen color ramp exists (color ramps based on https://colorbrewer2.org/) and custom colors are formatted correctly. For supported formats, see https://gka.github.io/chroma.js/.')
							return;
						}
						if (colorramp_rev) {
							console.log('reversing colorramp')
							colors.reverse(); 
						};
					}
					if (mode_point == "size") {
						pointMode_size_radiuses(pointSize);
					}
					if (mode_line == "width") {
						lineMode_width(lineWidth);
					}
					generateLegend(legendtitle, asc, legendrounding, mode_line, mode_point, typeOfFeatures);
				} else {
					console.error('Classnumber out of range (must be: 2 < x <', values.length, '(featurecount))!');
					return;
				}
				
				// setting symbology to features
				testdata.eachLayer(function(layer) {
					//console.log('feature type:', layer.feature.geometry.type)

					if (layer.feature.geometry.type == "Point") {
						var coords = layer.feature.geometry.coordinates;
						var marker = L.shapeMarker([coords[0], coords[1]] = [coords[1], coords[0]], (mode_point == "color" ? stylePoint_color(layer.feature.properties[field]) : stylePoint_size(layer.feature.properties[field])));
						marker.addTo(map);
						testdata.remove(); // to hide default icon markers - not the most elegant way of course
					}
					if (layer.feature.geometry.type == "LineString" || layer.feature.geometry.type == "MultiLineString") {
						layer.setStyle((mode_line == "width" ? styleLine_width(layer.feature.properties[field]) : styleLine_color(layer.feature.properties[field])))
					}
					if (layer.feature.geometry.type == "Polygon" || layer.feature.geometry.type == "MultiPolygon") {
						layer.setStyle(stylePolygon(layer.feature.properties[field]))
					}
					
				});

				console.log('Feature types in GeoJSON:', features_info)
			}
				
			var x=new XMLHttpRequest();
			x.open('get', 'points.geojson', false); 		// attribute to test with: Terfogat
			//x.open('get', 'us-states.geojson', false);	// attribute to test with: density
			//x.open('get', 'rivers.geojson', false);			// attribute to test with: Shape_Leng
			//x.open('get', 'test.geojson', false);
			x.send();
			var d=JSON.parse(x.responseText);
			var testdata = L.geoJSON(d).addTo(map); 		// if added to map, default point-markers are removed later due to custom markers being drawn separately
			map.fitBounds(testdata.getBounds());
			
			//start('quantile', 5, 'RdPu', 'Terfogat', 'Area (m<sup>2</sup>)'); 		// mode, numclasses, colorramp, field, legendtitle OLD
			start({
				mode: 'quantile',							// classification method: jenks, quantile, equalinterval
				classes: 5,									// desired number of classes (min: 3, max: 10 or featurecount, whichever is lower)
				pointMode: 'color', 						// POINT FEATURES: fill "color" or "size" (default: color)
				pointSizeMin: 2,							// POINT FEATURES: when pointMode: "size", define min point circle radius (default: 2)
				pointSizeMax: 10,							// POINT FEATURES: when pointMode: "size", define max point circle radius (default: 10, recommended max: 12)
				/*pointShape: 'circle',*/					// POINT FEATURES: shape of points: 'circle', 'square', 'diamond', 'triangle', etc. See https://github.com/rowanwins/Leaflet.SvgShapeMarkers. (default: 'circle')
				lineMode: 'width', 							// LINE FEATURES: stroke "color" or "width" (default: color)
				lineWidthMin: 1,							// LINE FEATURES: when lineMode: "width", define min stroke width (default: 1)
				lineWidthMax: 15,							// LINE FEATURES: when lineMode: "width", define max stroke width (default: 15, recommended max: 20)
				colorRamp: 'purd',							// color ramp to use in symbology. Based on ColorBrewer2 color ramps, included in Chroma.js: https://colorbrewer2.org/. (default: PuRd)
				colorCustom: [	'rgba(255,247,188,1)', 
								'#fec44fff', 
								'd95f0eff'],				// custom color ramp as an array, colors in format supported by Chroma.js, with opacity support. A minimum of two colors are required.
															// (examples for yellow: 'ffff00', '#ff0', 'yellow', '#ffff0055', 'rgba(255,255,0,0.35)', 'hsla(58,100%,50%,0.6)', 
															// chroma('yellow').alpha(0.5). For more, see: https://gka.github.io/chroma.js/)
															// Custom colors override colorRamp.
				legendAscending: false,						// true = values in legend will be ascending (low first, high last) (default: false)
				reverseColorRamp: false,					// true = reverse the chosen color ramp, both in symbology on map and legend colors. (default: false)
															// Useful if you found a great looking colorramp (green to red), but would prefer reversed colors 
															// (for example to match visual implications about colors: green implies positive, red implies negative phenomena)
				field: 'Terfogat', 							// target attribute field name. Case-sensitive!
				legendTitle: 'Area (m2)',					// title for legend (usually a description of visualized data). HTML-markdown and styling allowed. If you want to hide title, set this as ''. (default: ='field')
				legendRounding: true						// false = disable class boundary value rounding (default: true)
			}); 
			
			// color ramps:
			//    for sequential data: 	OrRd, PuBu, BuPu, Oranges, BuGn, YlOrBr, YlGn, Reds, RdPu, Greens, YlGnBu, 
			//							Purples, GnBu, Greys, YlOrRd, PuRd, Blues, PuBuGn, Viridis
			//    for diverging data:	PiYG, PRGn, BrBG, PuOr, RdGy, RdBu, RdYlBu, RdYlGn, Spectral
 			//    for qualitative data:	Accent, Set1, Paired, Set2, Dark2, Set3, Pastel1, Pastel2
			
			
			
			function generateLegend(title, asc, round, mode_line, mode_point, typeOfFeatures) {				
				var legend = L.control({position: 'bottomleft'});
				
				if (round) {
					for (var i=0; i<classes.length; i++) {
						classes[i] = classes[i].toFixed(0);
					}
					console.log('Class break values have been rounded to whole numbers.')
				}
				
				legend.onAdd = function (map) {
					var div = L.DomUtil.create('div', 'info legend');
					// legend title:
					div.innerHTML += '<div style="font-weight: bold; display: flex; justify-content: center; margin-bottom: 5px; max-width: 170px;">' + title + '</div>';
					// legenditems container
					var container = '';
					
					// type of features
					if (typeOfFeatures == "MultiPoint" || typeOfFeatures == "Point") {
						// points
						switch (asc) {
							// ascending legend
							case true:
								switch (mode_point) {
									case 'color':
									// color based categories
										for (var i = 0; i < classes.length; i++) {
											console.log('Legend: building line', i+1)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<circle cx="12.5" cy="12.5" r="8" style="stroke: black; fill: '+colors[i]+';"/>'+
													'</svg>'+
													'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] : ' <')+'</div>'+
												'</div>';
										}
										break;
									case 'size':
									// size (radius) based categories
										for (var i = 0; i < classes.length; i++) {
											console.log('Legend: building line', i+1)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<circle cx="12.5" cy="12.5" r="'+radiuses[i]+'" style="stroke: black; fill: orange;"/>'+
													'</svg>'+
													'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] : ' <')+'</div>'+
												'</div>';
										}
										break;
								}
								break;
							// descending legend
							case false:
								switch (mode_point) {
									case 'color':
									// color based categories
										for (var i = classes.length; i > 0; i--) {
											console.log('Legend: building line', i)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<circle cx="12.5" cy="12.5" r="8" style="stroke: black; fill: '+colors[i-1]+';"/>'+
													'</svg>'+
													'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1]))+'</div>'+
												'</div>';
										}
										break;
									case 'size':
									// size (radius) based categories
										for (var i = classes.length; i > 0; i--) {
											console.log('Legend: building line', i)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<circle cx="12.5" cy="12.5" r="'+radiuses[i-1]+'" style="stroke: black; fill: orange;"/>'+
													'</svg>'+
													'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1]))+'</div>'+
												'</div>';
										}
										break;
								}
								break;
						}
					} else if (typeOfFeatures == "MultiLineString" || typeOfFeatures == "LineString") {
						// lines
						switch (asc) {
							case true:
							// ascending legend
								switch (mode_line) {
									case 'color':
									// color based categories
										for (var i = 0; i < classes.length; i++) {
											console.log('Legend: building line', i+1)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<i style="background: ' + colors[i] + '"></i> ' +
													'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] : ' <')+'</div>'+
												'</div>';
										}
										break;
									case 'width':
									// width based categories
										for (var i = 0; i < classes.length; i++) {
											console.log('Legend: building line', i+1)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<line x1="0" y1="12.5" x2="25" y2="12.5" style="stroke-width: '+widths[i]+'; stroke: #3687fa;"/>'+
													'</svg>'+
													'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] : ' <')+'</div>'+
												'</div>';
										}
										break;
								}
								break;
							case false:
							// descending legend
								switch (mode_line) {
									case 'color':
									// color based categories
										for (var i = classes.length; i > 0; i--) {
											console.log('Legend: building line', i)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<i style="background: ' + colors[i-1] + '"></i>' +
													'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1]))+'</div>'+
												'</div>'
										}
										break;
									case 'width':
									// width based categories
										for (var i = classes.length; i > 0; i--) {
											console.log('Legend: building line', i)
											container +=
												'<div style="display: flex; flex-direction: row; align-items: center">'+
													'<svg width="25" height="25" viewBox="0 0 25 25" style="margin-left: 4px; margin-right: 10px">'+
														'<line x1="0" y1="12.5" x2="25" y2="12.5" style="stroke-width: '+widths[i-1]+'; stroke: #3687fa;"/>'+
													'</svg>'+
												'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1]))+'</div>'+
												'</div>'
										}
										break;
								}
								break;
						}
					} else {
						// polygons
						switch (asc) {
							case true:
							// ascending legend
								for (var i = 0; i < classes.length; i++) {
									console.log('Legend: building line', i+1)
									container +=
										'<div style="display: flex; flex-direction: row; align-items: center">'+
											'<i style="background: ' + colors[i] + '"></i> ' +
											'<div>'+(i == 0 ? '< ' : classes[i] + (classes[i + 1] ? ' &ndash; ' : '')) + (classes[i + 1] ? classes[i + 1] : ' <')+'</div>'+
										'</div>';
								}
								break;
							case false:
							// descending legend
								for (var i = classes.length; i > 0; i--) {
									console.log('Legend: building line', i)
									container +=
										'<div style="display: flex; flex-direction: row; align-items: center">'+
											'<i style="background: ' + colors[i-1] + '"></i>' +
											'<div>'+(i == 1 ? '< ' : '') + (i == classes.length ? classes[i-1] + ' <' : classes[i] + (i == 1 ? '' : ' &ndash; ' + classes[i-1]))+'</div>'+
										'</div>'
								}
								break;
						}
					}
					
					div.innerHTML += container;
					return div;
				};
				
				console.log('Legend generated.');
				legend.addTo(map);
			}
			
			
			
			function unixTimestampSolver(ts, mode) {
				if (mode == "hhmmss") {
					var date = new Date(ts*1000).toLocaleString("hu-HU", {hour: '2-digit', minute: '2-digit', second: '2-digit'});				
				} else if (mode == "full") {
					var date = new Date(ts*1000).toLocaleString("hu-HU");				
				} else if (mode == "fullutc") {
					var date = new Date(ts*1000).toUTCString();				
				}
				return date;
			}
				
				
				
				
			// JENKS FUNCTIONS FROM SIMPLESTATISTICS - should be loaded as a library 
			// instead of inserting it here... but at least it works this way!
			
			ss.jenks = function(data, n_classes) {

				// sort data in numerical order
				data = data.slice().sort(function (a, b) { return a - b; });

				// get our basic matrices
				var matrices = ss.jenksMatrices(data, n_classes),
					// we only need lower class limits here
					lower_class_limits = matrices.lower_class_limits,
					k = data.length - 1,
					kclass = [],
					countNum = n_classes;

				// the calculation of classes will never include the upper and
				// lower bounds, so we need to explicitly set them
				kclass[n_classes] = data[data.length - 1];
				kclass[0] = data[0];

				// the lower_class_limits matrix is used as indexes into itself
				// here: the `k` variable is reused in each iteration.
				while (countNum > 1) {
					kclass[countNum - 1] = data[lower_class_limits[k][countNum] - 2];
					k = lower_class_limits[k][countNum] - 1;
					countNum--;
				}

				return kclass;
			};
			
				ss.jenksMatrices = function(data, n_classes) {

					// in the original implementation, these matrices are referred to
					// as `LC` and `OP`
					//
					// * lower_class_limits (LC): optimal lower class limits
					// * variance_combinations (OP): optimal variance combinations for all classes
					var lower_class_limits = [],
						variance_combinations = [],
						// loop counters
						i, j,
						// the variance, as computed at each step in the calculation
						variance = 0;

					// Initialize and fill each matrix with zeroes
					for (i = 0; i < data.length + 1; i++) {
						var tmp1 = [], tmp2 = [];
						for (j = 0; j < n_classes + 1; j++) {
							tmp1.push(0);
							tmp2.push(0);
						}
						lower_class_limits.push(tmp1);
						variance_combinations.push(tmp2);
					}

					for (i = 1; i < n_classes + 1; i++) {
						lower_class_limits[1][i] = 1;
						variance_combinations[1][i] = 0;
						// in the original implementation, 9999999 is used but
						// since Javascript has `Infinity`, we use that.
						for (j = 2; j < data.length + 1; j++) {
							variance_combinations[j][i] = Infinity;
						}
					}

					for (var l = 2; l < data.length + 1; l++) {

						// `SZ` originally. this is the sum of the values seen thus
						// far when calculating variance.
						var sum = 0, 
							// `ZSQ` originally. the sum of squares of values seen
							// thus far
							sum_squares = 0,
							// `WT` originally. This is the number of 
							w = 0,
							// `IV` originally
							i4 = 0;

						// in several instances, you could say `Math.pow(x, 2)`
						// instead of `x * x`, but this is slower in some browsers
						// introduces an unnecessary concept.
						for (var m = 1; m < l + 1; m++) {

							// `III` originally
							var lower_class_limit = l - m + 1,
								val = data[lower_class_limit - 1];

							// here we're estimating variance for each potential classing
							// of the data, for each potential number of classes. `w`
							// is the number of data points considered so far.
							w++;

							// increase the current sum and sum-of-squares
							sum += val;
							sum_squares += val * val;

							// the variance at this point in the sequence is the difference
							// between the sum of squares and the total x 2, over the number
							// of samples.
							variance = sum_squares - (sum * sum) / w;

							i4 = lower_class_limit - 1;

							if (i4 !== 0) {
								for (j = 2; j < n_classes + 1; j++) {
									if (variance_combinations[l][j] >=
										(variance + variance_combinations[i4][j - 1])) {
										lower_class_limits[l][j] = lower_class_limit;
										variance_combinations[l][j] = variance +
											variance_combinations[i4][j - 1];
									}
								}
							}
						}

						lower_class_limits[l][1] = 1;
						variance_combinations[l][1] = variance;
					}

					return {
						lower_class_limits: lower_class_limits,
						variance_combinations: variance_combinations
					};
				};
			
		</script>	
	</body>
</html>